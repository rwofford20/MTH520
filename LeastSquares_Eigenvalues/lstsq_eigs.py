# lstsq_eigs.py"""Volume 1: Least Squares and Computing Eigenvalues.Rachel WoffordMTH 520May 6, 2022"""import numpy as npimport scipy as spfrom scipy import linalgfrom scipy.stats import linregressfrom matplotlib import pyplot as pltfrom pandas.plotting import scatter_matrix# Problem 1def least_squares(A, b):    """Calculate the least squares solutions to Ax = b by using the QR    decomposition.    Parameters:        A ((m,n) ndarray): A matrix of rank n <= m.        b ((m, ) ndarray): A vector of length m.    Returns:        x ((n, ) ndarray): The solution to the normal equations.    """    Q, R = sp.linalg.qr(A, mode='economic')    B = np.dot(Q.T,b)    x = sp.linalg.solve(R, B)    return x# Problem 2def line_fit():    """Find the least squares line that relates the year to the housing price    index for the data in housing.npy. Plot both the data points and the least    squares line.    """    data = np.load('housing.npy')    # Construct the matrix A (33x2)- first column is the years, second column is all 1's    years = data[:,0]    A = np.column_stack((years, np.ones((33,1))))        # Construct the vector b (33x1) - vector of the price index    b = data[:, 1]        # Use the function from Problem 1 to find the least squares solution    x = least_squares(A,b)        # Plot the data points as a scatter plot    plt.scatter(years, b, marker='o', color='magenta')        # Plot the least squares line    x_vals = np.linspace(0, data[-1,0])    y = x[0]*x_vals +x[1]    plt.plot(x_vals, y, color='green')    plt.show()        return x# Problem 3def polynomial_fit():    """Find the least squares polynomials of degree 3, 6, 9, and 12 that relate    the year to the housing price index for the data in housing.npy. Plot both    the data points and the least squares polynomials in individual subplots.    """    data = np.load('housing.npy')    # Construct matrix A and vector b    A = data[:,0]    #A = np.column_stack((years, np.ones((33,1))))    b = data[:, 1]        # Calculate the polynomials    x_vals = np.linspace(0, data[-1,0])        # Degree 3    A3 = np.vander(A,4)    x3 = linalg.lstsq(A3,b)[0]    plt.subplot(221)    plt.scatter(A,b)    y = np.polynomial.polynomial.Polynomial(x3[::-1])    plt.title('Degree 3 Polynomial')    plt.plot(x_vals, y(x_vals))        # Degree 6    A6 = np.vander(A,7)    x6 = linalg.lstsq(A6,b)[0]    plt.subplot(222)    plt.scatter(A,b)    y = np.polynomial.polynomial.Polynomial(x6[::-1])    plt.title('Degree 6 Polynomial')    plt.plot(x_vals, y(x_vals))        # Degree 9    A9 = np.vander(A,9)    x9 = linalg.lstsq(A9,b)[0]    plt.subplot(223)    plt.scatter(A,b)    y = np.polynomial.polynomial.Polynomial(x9[::-1])    plt.title('Degree 9 Polynomial')    plt.plot(x_vals, y(x_vals))        # Degree 12    A12 = np.vander(A,12)    x12 = linalg.lstsq(A12,b)[0]    plt.subplot(224)    plt.scatter(A,b)    y = np.polynomial.polynomial.Polynomial(x12[::-1])    plt.title('Degree 12 Polynomial')    plt.plot(x_vals, y(x_vals))        plt.show()        returndef plot_ellipse(a, b, c, d, e):    """Plot an ellipse of the form ax^2 + bx + cxy + dy + ey^2 = 1."""    theta = np.linspace(0, 2*np.pi, 200)    cos_t, sin_t = np.cos(theta), np.sin(theta)    A = a*(cos_t**2) + c*cos_t*sin_t + e*(sin_t**2)    B = b*cos_t + d*sin_t    r = (-B + np.sqrt(B**2 + 4*A)) / (2*A)    plt.plot(r*cos_t, r*sin_t)    plt.gca().set_aspect("equal", "datalim")# Problem 4def ellipse_fit():    """Calculate the parameters for the ellipse that best fits the data in    ellipse.npy. Plot the original data points and the ellipse together, using    plot_ellipse() to plot the ellipse.    """    raise NotImplementedError("Problem 4 Incomplete")# Problem 5def power_method(A, N=20, tol=1e-12):    """Compute the dominant eigenvalue of A and a corresponding eigenvector    via the power method.    Parameters:        A ((n,n) ndarray): A square matrix.        N (int): The maximum number of iterations.        tol (float): The stopping tolerance.    Returns:        (float): The dominant eigenvalue of A.        ((n,) ndarray): An eigenvector corresponding to the dominant            eigenvalue of A.    """    raise NotImplementedError("Problem 5 Incomplete")# Problem 6def qr_algorithm(A, N=50, tol=1e-12):    """Compute the eigenvalues of A via the QR algorithm.    Parameters:        A ((n,n) ndarray): A square matrix.        N (int): The number of iterations to run the QR algorithm.        tol (float): The threshold value for determining if a diagonal S_i            block is 1x1 or 2x2.    Returns:        ((n,) ndarray): The eigenvalues of A.    """    raise NotImplementedError("Problem 6 Incomplete")        if __name__=='__main__':    # Function call corresponding to problem 1    A = np.array([[1,2],[2,5], [3,9]])    b = np.array([[4],[7], [11]])    #print(least_squares(A,b))        # Function call to problem 2    #print(line_fit())        # Function call to problem 3    #print(polynomial_fit())